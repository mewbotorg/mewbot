#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2021 - 2023 Mewbot Developers <mewbot@quicksilver.london>
#
# SPDX-License-Identifier: BSD-2-Clause

"""
The core interface definitions for mewbot.

This module provides a set of types that can be checked at runtime, allowing
components to be developed.

This module contains:

 - The base class for all InputEvents
 - The base class for InputEventProtocols, allowing duck-typing of events
 - The metaclasses for the above which allow InputEventProtocols to be considered
   subclasses of InputEvents and arbitrary InputEvents to have instance checks against them.
"""

from __future__ import annotations

from typing import Any

import abc
import dataclasses


class ProtoHandler(abc.ABCMeta):
    """Metaclass for InputEvent which masquerades InputEventProtocol as subclasses."""

    def __subclasscheck__(cls, subclass: type[Any]) -> bool:
        """Override issubclass(? extends InputEventProtocol, InputEvent) to True."""
        if cls == InputEvent and issubclass(subclass, InputEventProtocol):
            return True

        return super().__subclasscheck__(subclass)


@dataclasses.dataclass
class InputEvent(metaclass=ProtoHandler):
    """
    Base class for all events being generated by :class:`~mewbot.core.InputInterface`.

    Events are put on the :class:`~mewbot.core.InputQueue` and are then processed
    by :class:`~mewbot.core.Behaviour`

    This base event has no data or properties. Events must be immutable.
    """


class ProtoChecker(abc.ABCMeta):
    """
    Handler that checks if InputEvent instances conform to an InputEventProtocol.

    This class handles:
     - Working out the requirements of the protocol.
     - Overriding `isinstance` to check if InputEvent instances match the protocol.
    """

    def __instancecheck__(cls, instance: Any) -> bool:
        """
        Override isinstance() when testing against InputEventProtocol classes.

        If the object is an InputEvent and the target class is a subclass of
        InputEventProtocol, we check that the event has all the properties
        defined in the protocol. Properties are type checked excluding generics.
        This includes functions, which are erased to just `Callable`.
        """

        if not isinstance(instance, InputEvent):
            return super().__instancecheck__(instance)

        if not issubclass(cls, InputEventProtocol):
            return super().__instancecheck__(instance)

        # The target object has all
        method_check = (
            hasattr(instance, attr) and callable(getattr(instance, attr))
            for attr in ProtoChecker._get_callables(cls)
        )
        property_check = (
            hasattr(instance, attr) and isinstance(getattr(instance, attr), type_hint)
            for attr, type_hint in ProtoChecker._get_properties(cls).items()
        )

        return all(method_check) and all(property_check)

    @staticmethod
    def _get_callables(proto: type[InputEventProtocol]) -> list[str]:
        """Get a list of the functions that are required by the protocol."""
        # FIXME: This should be dynamic
        return []

    @staticmethod
    def _get_properties(proto: type[InputEventProtocol]) -> dict[str, type[Any]]:
        """Get a mapping of the properties required by the protocol, and their types."""
        # FIXME: This should be dynamic
        return {"message": str}


class InputEventProtocol(metaclass=ProtoChecker):  # pylint: disable=too-few-public-methods
    """
    Marker class to indicate a Protocol/Interface that can be applied to InputEvents.

    These interfaces can either specify that there are certain attributes or methods.
    - Methods are not type-checked beyond being callable.
    - Properties are type checked when doing an isinstance call.

    These protocol Classes are considered subclasses of InputEvent for the purpose
    of declaring interests in event types.
    """

    def __init__(self) -> None:
        raise RuntimeError("Can not instantiate a InputEventProtocol")

    def __init_subclass__(cls, **kwargs: Any):
        """Ensure that no subclasses have a functional __init__ method."""
        super().__init_subclass__(**kwargs)
        cls.__init__ = InputEventProtocol.__init__  # type: ignore
