#!/usr/bin/env python3

from __future__ import annotations

import dataclasses
from typing import AsyncGenerator, Dict, Optional, Set, Type

import asyncio
import logging

import watchfiles
from watchfiles.main import FileChange
from aiopath.path import AsyncPath

from mewbot.api.v1 import Input
from mewbot.core import InputEvent


class FileMonitorInputEvent(InputEvent):
    """
    Base class for file related input events generated by the file system.
    """

    file: AsyncPath

    def __init__(self, file: AsyncPath) -> None:
        super().__init__()
        self.file = file

    @property
    def path(self) -> str:
        return str(self.file)


@dataclasses.dataclass(init=False)
class FileMonitorAcquiredInputEvent(FileMonitorInputEvent):
    """FIXME: Update
    Called when a file is created - either at the location which is being monitored or inside a dir
    which is being monitored.
    """


@dataclasses.dataclass(init=False)
class MonitoredFileWasCreatedInputEvent(FileMonitorInputEvent):
    """FIXME: Update
    Called when a file is created - either at the location which is being monitored or inside a dir
    which is being monitored.
    """


@dataclasses.dataclass(init=False)
class MonitoredFileWasUpdatedInputEvent(FileMonitorInputEvent):
    """FIXME: Update
    Called when a file is updated - either at the location which is being monitored or inside a dir
    which is being monitored.
    """


@dataclasses.dataclass(init=False)
class MonitoredFileWasDeletedOrMovedInputEvent(FileMonitorInputEvent):
    """FIXME: Update
    Event called when a file is removed from the monitored location - the input location.
    Note - the input cannot distinguish between a file being deleted or moved away from the input
    location.
    """


_EVENT_MAP: Dict[watchfiles.Change, Type[FileMonitorInputEvent]] = {
    watchfiles.Change.added: MonitoredFileWasCreatedInputEvent,
    watchfiles.Change.modified: MonitoredFileWasUpdatedInputEvent,
    watchfiles.Change.deleted: MonitoredFileWasDeletedOrMovedInputEvent,
}


class FileMonitorInput(Input):
    """
    Using watchfiles as a backend to watch for events from a single file.
    Augmented by checks so that the system responds properly if the file does not initially exist.
    Or is deleted during the monitoring process.
    If the watcher is started on a folder, it will wait for the folder to go away before starting.
    If the file is deleted and replaced with a folder, it will wait for the folder to be replaced
    with a file before monitoring.
    """

    @staticmethod
    def produces_inputs() -> Set[Type[InputEvent]]:
        """
        Defines the set of input events this Input class can produce.
        This type of InputClass monitors a single file
        So a number of the file type inputs make no sense for it.
        """
        return {
            MonitoredFileWasCreatedInputEvent,  # A file is created at the monitored point
            MonitoredFileWasUpdatedInputEvent,  # The monitored file is updated
            MonitoredFileWasDeletedOrMovedInputEvent,  # The monitored file is deleted
        }

    _logger: logging.Logger

    _monitored_path: Optional[AsyncPath]  # A location on the file system to monitor
    _path_change_event: asyncio.Event  # Event to trigger if path is updated

    _run: bool = False  # Whether the run loop should continue (i.e. not shutdown)
    _path_was_deleted: bool = False  # Whether we observe the path was deleted.
    _polling_interval: float = 0.5

    def __init__(self, path: Optional[AsyncPath] = None) -> None:
        super().__init__()

        self._logger = logging.getLogger(__name__ + ":" + type(self).__name__)
        self._path_change_event = asyncio.Event()
        self._monitored_path = path

    @property
    def input_path(self) -> Optional[str]:
        return str(self._monitored_path) if self._monitored_path else None

    @input_path.setter
    def input_path(self, new_input_path: Optional[str]) -> None:
        self._monitored_path = AsyncPath(new_input_path)
        self._path_change_event.set()

    async def run(self) -> None:
        self._logger.info("Starting File Monitor")
        self._run = True
        # Always reset the event when we start a new run.
        self._path_change_event = asyncio.Event()

        if not self.queue:
            raise Exception

        while self._run:
            self._logger.info("Starting up file monitor, acquiring config")
            path = await self._wait_for_path_selection()

            if path is None:
                self._logger.info("Path not acquired (path changed or shutting down?)")
                continue

            self._logger.info("Starting up file monitor, using path is %s", path)
            watcher = await self._acquire_watcher(path)

            if watcher is None:
                self._logger.info("Watcher not acquired (path changed or shutting down?)")
                continue

            if self._path_was_deleted:
                await self.queue.put(MonitoredFileWasCreatedInputEvent(path))

            await self.queue.put(FileMonitorAcquiredInputEvent(path))
            async for event in self._monitor_file_watcher(watcher):
                self._logger.debug("Sending event %s", event)
                await self.queue.put(event)

        self._logger.info("FileMonitorInput exiting run loop")

    async def shutdown(self) -> None:
        self._logger.info("Requesting shutdown of FileMonitor")
        self._run = False
        self._path_change_event.set()

    async def _wait_for_path_selection(self) -> Optional[AsyncPath]:
        while self._run and not self._monitored_path:
            self._logger.info("No path selected, waiting for one to be set")

            # Wait for the event trigger, caused by changing the path
            # or a call to the shutdown method.
            await self._path_change_event.wait()

            # Reset the event flag, as it will have been set above
            self._path_change_event = asyncio.Event()

        return self._monitored_path

    async def _acquire_watcher(
        self, path: AsyncPath
    ) -> Optional[AsyncGenerator[Set[FileChange], None]]:
        if not await path.is_file():
            self._logger.info("Path %s not a regular file, waiting...", path)
            self._path_was_deleted = True

            if not await self._wait_for_path_to_be_regular_file(path):
                # Waiting exited before the file exists due to the event flag being set.
                return None

        # Ensure we're still watching the correct path, then reset the event.
        if self._monitored_path != path:
            return None

        self._path_change_event = asyncio.Event()
        return watchfiles.awatch(path, stop_event=self._path_change_event)

    async def _wait_for_path_to_be_regular_file(self, path: AsyncPath) -> bool:
        """
        Preforms a check on the file - updating if needed.
        """
        while self._run and not self._path_change_event.is_set():
            self._logger.debug("Checking for %s", path)
            exists = await path.exists()
            is_file = await path.is_file()

            # If the file doesn't currently exist, wait until it turns up
            if exists and is_file:
                self._logger.debug("File has become available")
                return True

            self._logger.debug(
                "Path is not a regular: exists=%s, is_file=%s", exists, is_file
            )
            await asyncio.sleep(self._polling_interval)

        self._logger.info(
            "Abandoning watcher acquisition %s",
            "Requested path changed" if self._run else "Input shutting down",
        )
        return False

    async def _monitor_file_watcher(
        self, watcher: AsyncGenerator[Set[FileChange], None]
    ) -> AsyncGenerator[FileMonitorInputEvent, None]:
        """
        Actually do the job of monitoring and responding to the watcher.
        If the file is detected as deleted, then the
        """
        self._logger.info("Reading events for existing regular file %s", self._monitored_path)

        async for changes in watcher:
            # Changes are sets of chance objects
            # tuples with
            #  - the first entry being a watchfiles.Change object
            #  - the second element being a str path to the changed item

            for change in changes:
                change_type, change_path = change
                event_type = _EVENT_MAP.get(change_type)

                if not event_type:
                    self._logger.error(
                        "Unexpected event type in file change - %s", change_type
                    )
                    continue

                yield event_type(file=AsyncPath(change_path))

                # If the file has been deleted, commence watcher reset.
                if change_type == watchfiles.Change.deleted:
                    self._path_was_deleted = True
                    self._path_change_event.set()
                    break
