from __future__ import annotations

import asyncio
import dataclasses
import logging
import os
import sys
import timeit

from typing import Set, Optional, Union, Any, Type

from aiopath.path import AsyncPath
import watchdog  # type: ignore
from watchdog.events import FileSystemEvent, FileSystemEventHandler  # type: ignore
from watchdog.observers import Observer  # type: ignore

from mewbot.core import InputEvent

from .base import FileSystemInputEvent
from .file_monitor import (
    FileMonitorInputEvent,
    MonitoredFileWasCreatedInputEvent,
    MonitoredFileWasUpdatedInputEvent,
)
from ...api.v1 import Input


@dataclasses.dataclass
class DirectoryMonitorInputEvent(FileSystemInputEvent):
    """
    Base class for file related input events generated by the file system.
    """

    dir: AsyncPath

    @property
    def path(self) -> str:
        return str(self.dir)


@dataclasses.dataclass
class DirectoryCreatedInWatchedDirInputEvent(DirectoryMonitorInputEvent):
    """
    A dir has been created - either the dir we're monitoring - if we're monitoring one.
    Or at the given monitor location.
    """


@dataclasses.dataclass
class DirectoryInMonitoredDirectoryWasUpdatedInputEvent(DirectoryMonitorInputEvent):
    """
    A dir has been updated - either in the dir we're monitoring - if we're monitoring one.
    What this mostly means is the name of the dir has been updated.
    If the contents have been updated, it'll spew events of the appropriate type.
    """


@dataclasses.dataclass
class DirectoryMovedIntoOrFromWatchedDirInputEvent(DirectoryMonitorInputEvent):
    """
    A dir has been updated - either in the dir we're monitoring - if we're monitoring one.
    What this mostly means is the name of the dir has been updated.
    If the contents have been updated, it'll spew events of the appropriate type.
    """

    dir_moved_from: AsyncPath

    @property
    def moved_from_path(self) -> str:
        return str(self.dir_moved_from)


@dataclasses.dataclass
class DirectoryDeletedInMonitoredDirectoryInputEvent(DirectoryMonitorInputEvent):
    """
    A dir has been deleted - either in the dir we're monitoring - if we're monitoring one.
    """


class FileCreatedInMonitoredDirectoryInputEvent(
    FileMonitorInputEvent, DirectoryMonitorInputEvent
):
    """
    Event called when a dir comes into existence at the monitored location - the input location.
    Note - the input cannot distinguish between a dir being created or moved to the input location.
    """

    def __init__(self, monitored_directory: AsyncPath, created_path: AsyncPath) -> None:
        super(FileMonitorInputEvent, self).__init__(file=created_path)
        super(DirectoryMonitorInputEvent, self).__init__(dir=monitored_directory)

    @property
    def directory(self) -> str:
        return str(self.dir)

    @property
    def path(self) -> str:
        return str(self.file)


class FileUpdatedInMonitoredDirectoryInputEvent(
    FileMonitorInputEvent, DirectoryMonitorInputEvent
):
    """
    Event called when a dir comes into existence at the monitored location - the input location.
    Note - the input cannot distinguish between a dir being created or moved to the input location.
    """

    def __init__(self, monitored_directory: AsyncPath, created_path: AsyncPath) -> None:
        super(FileMonitorInputEvent, self).__init__(file=created_path)
        super(DirectoryMonitorInputEvent, self).__init__(dir=monitored_directory)

    @property
    def directory(self) -> str:
        return str(self.dir)

    @property
    def path(self) -> str:
        return str(self.file)


@dataclasses.dataclass
class FileDeletedFromMonitoredDirectoryInputEvent(
    FileMonitorInputEvent, DirectoryMonitorInputEvent
):
    """
    Event called when a dir is removed from the monitored location - the input location.
    Note - the input cannot distinguish between a dir being deleted or moved away from the input
    location.
    """

    def __init__(self, monitored_directory: AsyncPath, deleted_path: AsyncPath) -> None:
        super(FileMonitorInputEvent, self).__init__(file=deleted_path)
        super(DirectoryMonitorInputEvent, self).__init__(dir=monitored_directory)

    @property
    def directory(self) -> str:
        return str(self.dir)

    @property
    def path(self) -> str:
        return str(self.file)


class DirectoryMonitorInput(Input):
    """
    File system input intended for directory like objects.
    """

    _logger: logging.Logger

    _input_path: Optional[str] = None  # A location on the file system to monitor
    _input_path_exists: bool = False  # Was a something found at this location?

    _polling_interval: float = 0.5

    def __init__(self, input_path: Optional[str] = None) -> None:
        super(Input, self).__init__()  # pylint: disable=bad-super-call

        self._input_path = input_path

        self._logger = logging.getLogger(__name__ + ":" + type(self).__name__)

        if input_path is None or not os.path.exists(input_path):

            self._input_path_exists = False
            self._input_path_type = None

        elif not os.path.exists(input_path):

            self._input_path_exists = False
            self._input_path_type = None

        # The only case where the watcher can actually start
        elif self._input_path is not None:  # needed to fool pylint

            self._input_path_exists = True

            if os.path.isdir(self._input_path):
                self._input_path_type = "dir"
            else:
                self._input_path_type = "file"

        else:
            raise NotImplementedError

        # Because of backend issues the observer is OS dependant
        self._platform_str = sys.platform
        # Not using an f-string because we want lazy evaluation if possible
        self._logger.info("We are detected as running on %s", self._platform_str)

    @staticmethod
    def produces_inputs() -> Set[Type[InputEvent]]:
        """
        Defines the set of input events this Input class can produce.
        This is intended to be run on a dir - so will produce events for all the things
        in the dir as well.
        Additionally, the dir being monitored itself can be deleted.
        Hence, the final two event types.
        """
        return {
            MonitoredFileWasCreatedInputEvent,
            MonitoredFileWasUpdatedInputEvent,
            DirectoryCreatedInWatchedDirInputEvent,
            DirectoryInMonitoredDirectoryWasUpdatedInputEvent,
            DirectoryDeletedInMonitoredDirectoryInputEvent,
            FileCreatedInMonitoredDirectoryInputEvent,
            FileDeletedFromMonitoredDirectoryInputEvent,
        }

    @property
    def input_path(self) -> Optional[str]:
        return self._input_path

    @input_path.setter
    def input_path(self, new_input_path: Optional[str]) -> None:
        self._input_path = new_input_path

    @property
    def input_path_exists(self) -> bool:
        return self._input_path_exists

    @input_path_exists.setter
    def input_path_exists(self, value: Any) -> None:
        """
        Input path is determined internally using some variant of os.path.
        """
        raise AttributeError("input_path_exists cannot be externally set")

    async def run(self) -> None:
        """
        Fires up an aiohttp app to run the service.
        Token needs to be set by this point.
        """
        # Restart if the input path changes ... might be a good idea
        if self._input_path_exists and self._input_path_type == "dir":
            self._logger.info(
                'Starting DirTypeFSInput - monitoring existing dir "%s"', self._input_path
            )

        else:
            self._logger.info(
                'Waiting to start DirTypeFSInput - provided input path did not exist "%s"',
                self._input_path,
            )

        while True:

            # We#re waiting for the thing we're monitoring to exist
            await self._monitor_input_path()

            assert self.input_path is not None

            # There's something at the location - it should be a dir - activate the watcher
            file_system_observer: Union[WindowsFileSystemObserver, LinuxFileSystemObserver]
            if self._platform_str == "win32":

                file_system_observer = WindowsFileSystemObserver(
                    output_queue=self.queue, input_path=self.input_path
                )

                self._input_path_exists = await file_system_observer.monitor_dir_watcher()
            else:
                file_system_observer = LinuxFileSystemObserver(
                    output_queue=self.queue, input_path=self.input_path
                )

                self._input_path_exists = await file_system_observer.monitor_dir_watcher()

    async def _monitor_input_path(self) -> None:
        """
        Preforms a check on the file - updating if needed.
        """
        if self._input_path_exists and self._input_path_type == "dir":
            return

        self._logger.info(
            "The provided input path will be monitored until a dir appears - %s - %s",
            self._input_path,
            self._input_path_type,
        )

        while True:

            if self._input_path is None:
                await asyncio.sleep(
                    self._polling_interval
                )  # Give the rest of the loop a chance to do something
                continue

            target_async_path: AsyncPath = AsyncPath(self._input_path)
            target_exists: bool = await target_async_path.exists()
            is_target_file: bool = await target_async_path.is_file()

            if target_exists and is_target_file:

                await asyncio.sleep(
                    self._polling_interval
                )  # Give the rest of the loop a chance to do something
                continue

            if not target_exists:

                await asyncio.sleep(
                    self._polling_interval
                )  # Give the rest of the loop a chance to do something
                continue

            # Something has come into existence since the last loop
            self._logger.info(
                "Something has appeared at the input_path - %s", self._input_path
            )

            asyncio.get_running_loop().create_task(
                self._input_path_dir_created_task(target_async_path)
            )

            self._input_path_exists = True
            return

    async def _input_path_dir_created_task(self, target_async_path: AsyncPath) -> None:
        """
        Called when _monitor_file detects that there's now something at the input_path location.
        Spun off into a separate method because want to get into starting the watch as fast as
        possible.
        """
        if self._input_path is None:
            self._logger.warning(
                "Unexpected call to _input_path_file_created_task - _input_path is None!"
            )
            return
        if self._input_path is not None and self._input_path_type == "file":
            self._logger.warning(
                "Unexpected call to _input_path_file_created_task - "
                "_input_path is not None but _input_path_type is file"
            )

        if await target_async_path.is_file():  # Not sure this case should ever be reached

            self._logger.info('New asset at "%s" detected as file', self._input_path)

        elif await target_async_path.is_dir():

            self._logger.info('New asset at "%s" detected as dir', self._input_path)

            await self.send(
                FileCreatedInMonitoredDirectoryInputEvent(
                    monitored_directory=AsyncPath(self._input_path),
                    created_path=target_async_path,
                )
            )

        else:
            self._logger.warning(
                "Unexpected case in _input_path_created_task - %s", target_async_path
            )

    async def send(self, event: FileSystemInputEvent) -> None:

        if self.queue is None:
            return

        await self.queue.put(event)


class BaseObserver:
    _logger: logging.Logger

    _output_queue: Optional[asyncio.Queue[InputEvent]]
    _input_path: AsyncPath

    _watchdog_observer: Observer

    _internal_queue: asyncio.Queue[FileSystemEvent]

    def __init__(self, path: str) -> None:
        self._logger = logging.getLogger(__name__ + ":" + type(self).__name__)
        self._input_path = AsyncPath(path)
        self._watchdog_observer = Observer()
        self._internal_queue = asyncio.Queue()

    async def monitor_dir_watcher(self) -> bool:

        if self._input_path is not None:

            self.watch()
        else:
            self._logger.warning("self._input_path is None in run - this should not happen")
            raise NotImplementedError(
                "self._input_path is None in run - this should not happen"
            )

        dir_deleted = await self._process_queue()
        if dir_deleted:
            self._logger.info(
                "%s has been deleted - returning to wait mode", self._input_path
            )
            await self.send(
                FileDeletedFromMonitoredDirectoryInputEvent(
                    monitored_directory=AsyncPath(self._input_path),
                    deleted_path=AsyncPath(self._input_path),
                )
            )
            return False
        return True

    async def _process_queue(self) -> bool:
        """
        Take event off the internal queue, process them, and then put them on the wire.
        """
        target_async_path: AsyncPath = AsyncPath(self._input_path)

        while True:

            new_event = await self._internal_queue.get()

            # The events produced when the dir is deleted are not helpful
            # Currently not sure that watchdog elegantly indicates that it's had its target dir
            # deleted
            # TODO: So need this horrible hack. Will get the rest of it working, then optimize

            # No helpful info is provided by the watcher if the target dir itself is deleted
            # So need to check before each event

            target_exists: bool = await target_async_path.exists()

            if not target_exists:
                self._logger.info("Delete event detected - %s is gone", self._input_path)
                return True

            await self._process_event(new_event)

    #
    # async def _input_path_created_task(self, target_async_path: AsyncPath) -> None:
    #     """
    #     Called when _monitor_file detects that there's now something at the input_path location.
    #     Spun off into a separate method because want to get into starting the watch as fast as
    #     possible.
    #     """
    #     if self._input_path is None:
    #         self._logger.warning(
    #             "Unexpected call to _input_path_created_task - _input_path is None!"
    #         )
    #         return
    #
    #     if await target_async_path.is_dir():
    #
    #         self._logger.info('New asset at "%s" detected as dir', self._input_path)
    #
    #         await self.send(CreatedDirFSInputEvent(dir=target_async_path, base_event=None))
    #
    #     elif await target_async_path.is_file():
    #
    #         self._logger.info('New asset at "%s" detected as file', self._input_path)
    #
    #         await self.send(FileCreatedInWatchedDirInputEvent(
    #             file=target_async_path, base_event=None
    #         ))
    #
    #     else:
    #         self._logger.warning(
    #             "Unexpected case in _input_path_created_task - %s", target_async_path
    #         )

    async def send(self, event: FileSystemInputEvent) -> None:
        # FIXME: consider moving this up?
        if self._output_queue is None:
            return

        await self._output_queue.put(event)

    async def _process_event(self, event: FileSystemEvent) -> None:
        """
        Take an event and process it before putting it on the wire.
        """
        # Filter null events
        if event is None:
            return

        if not isinstance(event, FileSystemEvent):
            self._logger.error("Unhandled event in _process_event - %s", event)
            return

        if event.is_directory:
            await self._process_dir_event(event)
        else:
            await self._process_file_event(event)

    def watch(self) -> None:
        """
        Use watchdog in a separate thread to watch a dir for changes.
        """
        handler = _EventHandler(queue=self._internal_queue, loop=asyncio.get_event_loop())

        self._watchdog_observer = Observer()
        self._watchdog_observer.schedule(
            event_handler=handler, path=str(self._input_path), recursive=True
        )
        self._watchdog_observer.start()

        self._logger.info("Started _watchdog_observer")

        # TODO: remove this debug wrapper around join
        print(timeit.timeit(lambda: self._watchdog_observer.join(10)))

        try:
            asyncio.get_event_loop().call_soon_threadsafe(
                self._internal_queue.put_nowait, None
            )
        except RuntimeError:  # Can happen when the shutdown is not clean
            return

    async def _process_file_event(self, event: FileSystemEvent) -> None:
        """
        Take an event and process it before putting it on the wire.
        """

        if isinstance(event, watchdog.events.FileCreatedEvent):
            await self._process_file_creation_event(event)

        elif isinstance(event, watchdog.events.FileModifiedEvent):
            await self._process_file_modified_event(event)

        elif isinstance(event, watchdog.events.FileMovedEvent):
            await self._process_file_move_event(event)

        elif isinstance(event, watchdog.events.FileDeletedEvent):
            await self._process_file_delete_event(event)

        else:
            self._logger.warning("Unexpected case in _process_file_event - %s", event)

    async def _process_file_creation_event(
        self, event: watchdog.events.FileCreatedEvent
    ) -> None:
        raise NotImplementedError("Cannot handle FileCreatedEvent")

    async def _process_file_modified_event(
        self, event: watchdog.events.FileModifiedEvent
    ) -> None:
        raise NotImplementedError("Cannot handle FileModifiedEvent")

    async def _process_file_move_event(
        self,
        event: Union[
            watchdog.events.FileSystemMovedEvent, watchdog.events.FileSystemMovedEvent
        ],
    ) -> None:
        raise NotImplementedError(
            "Cannot handle FileSystemMovedEvent or FileSystemMovedEvent"
        )

    async def _process_file_delete_event(
        self, event: watchdog.events.FileDeletedEvent
    ) -> None:
        raise NotImplementedError("Cannot handle FileDeletedEvent")

    async def _process_dir_event(self, event: FileSystemEvent) -> None:
        """
        Take an event and process it before putting it on the wire.
        """

        # DIRS
        if isinstance(event, watchdog.events.DirCreatedEvent):
            await self.send(
                DirectoryCreatedInWatchedDirInputEvent(
                    dir=AsyncPath(event.src_path),
                    base_event=event,
                )
            )

        elif isinstance(event, watchdog.events.DirModifiedEvent):
            await self.send(
                DirectoryInMonitoredDirectoryWasUpdatedInputEvent(
                    dir=AsyncPath(event.src_path),
                    base_event=event,
                )
            )

        elif isinstance(event, watchdog.events.DirMovedEvent):

            await self.send(
                DirectoryMovedIntoOrFromWatchedDirInputEvent(
                    dir_moved_from=AsyncPath(event.src_path),
                    dir=AsyncPath(event.dest_path),
                    base_event=event,
                )
            )

        elif isinstance(event, watchdog.events.DirDeletedEvent):

            await self.send(
                DirectoryDeletedInMonitoredDirectoryInputEvent(
                    dir=AsyncPath(event.src_path),
                    base_event=event,
                )
            )


class WindowsFileSystemObserver(BaseObserver):
    """
    Does the job of actually observing the file system.
    Isolated here because the observer subsystem for windows is particularly problematic, and it
    should be swapped out wholesale where possible.
    """

    # workaround for a problem with file monitors on Windows
    # when a file is deleted you receive several modification events before the delete event.
    # These are meaningless - the file is, in truth, already gone
    # This cache contains file paths which the user has been told have been deleted.
    # And python believes to be gone
    # Removed from the cache when an actual delete event comes in, or a creation/move to event
    # TODO: LRUCache instead of set?
    _python_registers_deleted_cache: Set[str] = set()
    _python_registers_created_cache: Set[str] = set()

    _dir_cache: Set[str]
    _input_path: AsyncPath

    def __init__(
        self, output_queue: Optional[asyncio.Queue[InputEvent]], input_path: str
    ) -> None:
        super().__init__(input_path)
        self._output_queue = output_queue

        # FIXME: Don't like this being done sync in the constructor
        self._dir_cache = set()
        self.build_dir_cache()

    def build_dir_cache(self) -> None:
        """
        On Windows DIR deletion events are being reported as FILE del events.
        There is no good way to check the status of an object after it's gone,
        thus need to cache all the dirs first.
        """
        if self._input_path is None:
            return

        self._logger.info("Building dir cache for %s", self._input_path)
        for root, dirs, _ in os.walk(top=self._input_path):
            self._dir_cache.update(set(os.path.join(root, dn) for dn in dirs))
        self._logger.info(
            "dir cache built for %s - %i dirs found", self._input_path, len(self._dir_cache)
        )

    async def _process_file_creation_event(
        self, event: watchdog.events.FileCreatedEvent
    ) -> None:

        file_async_path = AsyncPath(event.src_path)

        if not await file_async_path.exists():
            # zombie event - appeal to reality says the file does not exist
            return

        if event.src_path in self._python_registers_created_cache:
            # User has already been notified - no reason to tell them again
            return

        # After one of these there very much should be something at the target loc
        self._python_registers_deleted_cache.discard(event.src_path)
        self._python_registers_created_cache.add(event.src_path)

        await self.send(
            FileCreatedInMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                created_path=AsyncPath(event.src_path),
            )
        )

    async def _dispatch_file_created(
        self, event: watchdog.events.FileSystemEvent, file_async_path: AsyncPath
    ) -> None:
        # We're getting modification events - and the file exists
        # where once it was registered as deleted
        # So tell the user the file exists again
        self._python_registers_deleted_cache.discard(event.src_path)
        self._python_registers_created_cache.add(event.src_path)

        await self.send(
            FileCreatedInMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                created_path=file_async_path,
            )
        )

    async def _process_file_modified_event(
        self, event: watchdog.events.FileModifiedEvent
    ) -> None:

        file_async_path = AsyncPath(event.src_path)

        if await file_async_path.exists():
            # This might be a legit event

            if event.src_path in self._python_registers_deleted_cache:
                return await self._dispatch_file_created(event, file_async_path)

            # Inotify on linux also notifies you of a change to the folder in this case

            dir_path = os.path.split(event.src_path)[0]

            await self.send(
                DirectoryInMonitoredDirectoryWasUpdatedInputEvent(
                    dir=AsyncPath(dir_path),
                    base_event=None,
                )
            )

            await self.send(
                FileUpdatedInMonitoredDirectoryInputEvent(
                    monitored_directory=self._input_path,
                    created_path=file_async_path,
                )
            )

        else:

            if event.src_path in self._python_registers_deleted_cache:
                # User has already been informed - no need to do anything
                # Any modification events we get here are stale
                return

            # User might think the file still exists - tell them it does not

            # Note that the user has been informed the file is gone
            self._python_registers_deleted_cache.add(event.src_path)
            # The user can be informed again that the file exists
            self._python_registers_created_cache.remove(event.src_path)

            dir_path = os.path.split(event.src_path)[0]

            await self.send(
                DirectoryInMonitoredDirectoryWasUpdatedInputEvent(
                    dir=AsyncPath(dir_path),
                    base_event=None,
                )
            )

            await self.send(
                FileDeletedFromMonitoredDirectoryInputEvent(
                    monitored_directory=self._input_path,
                    deleted_path=AsyncPath(event.src_path),
                )
            )

    async def _process_file_move_event(
        self,
        event: Union[
            watchdog.events.FileSystemMovedEvent, watchdog.events.FileSystemMovedEvent
        ],
    ) -> None:

        if isinstance(event, watchdog.events.FileSystemMovedEvent):
            self._logger.info("System moved a file %s", str(event))

        # Unfortunately, we're getting these events when a file is moved as well
        if event.src_path in self._dir_cache:

            self._dir_cache.discard(event.src_path)
            self._dir_cache.add(event.dest_path)
            await self.send(
                DirectoryMovedIntoOrFromWatchedDirInputEvent(
                    dir_moved_from=AsyncPath(event.src_path),
                    dir=AsyncPath(event.dest_path),
                    base_event=event,
                )
            )
            return

        # Hopefully, from this point on, any modified and deleted events are legit.
        # The user has been effectively told that the src_path no longer exists
        self._python_registers_deleted_cache.add(event.src_path)
        self._python_registers_deleted_cache.discard(event.dest_path)

        # A file hs been moved into position
        # so the user does not need to be informed that one has been created
        # The user has been (effectively) informed that an object has been created here
        self._python_registers_created_cache.add(event.dest_path)
        self._python_registers_created_cache.discard(event.src_path)

        # FIXME: Do move events properly
        await self.send(
            FileDeletedFromMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                deleted_path=AsyncPath(event.src_path),
            )
        )
        await self.send(
            FileCreatedInMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                created_path=AsyncPath(event.dest_path),
            )
        )

    async def _process_file_delete_event(
        self, event: watchdog.events.FileDeletedEvent
    ) -> None:

        file_async_path = AsyncPath(event.src_path)

        # Only put a deletion event on the wire if
        # - we haven't done so already
        # - There has been no other events which could be sanely followed by a
        #   delete event
        # - The file does not, in fact, still exist

        if event.src_path in self._python_registers_deleted_cache:

            self._python_registers_deleted_cache.discard(event.src_path)

        elif not await file_async_path.exists():

            print(self._dir_cache)
            # For some reason the watcher is emitting file delete events when a dir is deleted
            if event.src_path in self._dir_cache:

                assert self._input_path is not None, "needed for pylint"

                # Inotify on linux also notifies you of a change to the folder in this case
                await self.send(
                    DirectoryInMonitoredDirectoryWasUpdatedInputEvent(
                        dir=AsyncPath(self._input_path),
                        base_event=None,
                    )
                )

                await self.send(
                    DirectoryDeletedInMonitoredDirectoryInputEvent(
                        dir=AsyncPath(event.src_path),
                        base_event=event,
                    )
                )
                return

            dir_path = os.path.split(event.src_path)[0]

            # Inotify on linux also notifies you of a change to the folder in this case
            await self.send(
                DirectoryInMonitoredDirectoryWasUpdatedInputEvent(
                    dir=AsyncPath(dir_path),
                    base_event=None,
                )
            )

            await self.send(
                FileDeletedFromMonitoredDirectoryInputEvent(
                    monitored_directory=self._input_path,
                    deleted_path=AsyncPath(event.src_path),
                )
            )

    async def _process_dir_event(self, event: FileSystemEvent) -> None:
        """
        Take an event and process it before putting it on the wire.
        """

        # DIRS
        if isinstance(event, watchdog.events.DirCreatedEvent):

            # A new directory has been created - record it
            self._dir_cache.add(event.src_path)
            await self.send(
                DirectoryCreatedInWatchedDirInputEvent(
                    dir=AsyncPath(event.src_path),
                    base_event=event,
                )
            )

        elif isinstance(event, watchdog.events.DirModifiedEvent):
            await self.send(
                DirectoryInMonitoredDirectoryWasUpdatedInputEvent(
                    dir=AsyncPath(event.src_path),
                    base_event=event,
                )
            )

        elif isinstance(event, watchdog.events.DirMovedEvent):

            # If a dir experiences a move event, the original dir effectively ceases to exist
            # And a new one appears - update the _dir_cache accordingly
            self._dir_cache.discard(event.src_path)
            self._dir_cache.add(event.dest_path)

            await self.send(
                DirectoryMovedIntoOrFromWatchedDirInputEvent(
                    dir_moved_from=AsyncPath(event.src_path),
                    dir=AsyncPath(event.dest_path),
                    base_event=event,
                )
            )

        elif isinstance(event, watchdog.events.DirDeletedEvent):

            # Not that I think you'll ever actually see one of these events
            # Because Windows registers a dir delete event as a file delete for some reason
            self._dir_cache.discard(event.src_path)

            await self.send(
                DirectoryDeletedInMonitoredDirectoryInputEvent(
                    dir=AsyncPath(event.src_path),
                    base_event=event,
                )
            )


class LinuxFileSystemObserver(BaseObserver):
    """
    Does the job of actually observing the file system.
    Isolated here because the observer subsystem for windows is particularly problematic, and it
    should be swapped out wholesale where possible.
    """

    def __init__(
        self, output_queue: Optional[asyncio.Queue[InputEvent]], input_path: str
    ) -> None:
        super().__init__(input_path)
        self._output_queue = output_queue

    async def _process_file_creation_event(
        self, event: watchdog.events.FileCreatedEvent
    ) -> None:

        await self.send(
            FileCreatedInMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                created_path=AsyncPath(event.src_path),
            )
        )

    async def _process_file_modified_event(
        self, event: watchdog.events.FileModifiedEvent
    ) -> None:

        file_async_path = AsyncPath(event.src_path)

        await self.send(
            FileUpdatedInMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path, created_path=file_async_path
            )
        )

    async def _process_file_move_event(
        self, event: watchdog.events.FileSystemMovedEvent
    ) -> None:
        # TODO: Test moving into, internal, and out of the watched directory
        # FIXME: Do move events properly
        await self.send(
            FileDeletedFromMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                deleted_path=AsyncPath(event.src_path),
            )
        )
        await self.send(
            FileCreatedInMonitoredDirectoryInputEvent(
                monitored_directory=self._input_path,
                created_path=AsyncPath(event.dest_path),
            )
        )

    async def _process_file_delete_event(
        self, event: watchdog.events.FileDeletedEvent
    ) -> None:
        await self.send(
            FileDeletedFromMonitoredDirectoryInputEvent(
                monitored_directory=AsyncPath(self._input_path),
                deleted_path=AsyncPath(event.src_path),
            )
        )


class _EventHandler(FileSystemEventHandler):  # type: ignore

    _loop: asyncio.AbstractEventLoop
    _queue: asyncio.Queue[FileSystemEvent]

    def __init__(
        self,
        queue: asyncio.Queue[FileSystemEvent],
        loop: asyncio.AbstractEventLoop,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        self._loop = loop
        self._queue = queue
        super().__init__(*args, **kwargs)

    def on_any_event(self, event: FileSystemEvent) -> None:
        try:
            self._loop.call_soon_threadsafe(self._queue.put_nowait, event)
        except RuntimeError:
            return
