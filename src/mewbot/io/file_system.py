#!/usr/bin/env python3

from __future__ import annotations

from typing import Optional, Set, Sequence, Type

import asyncio
import dataclasses
import logging

import aiopath  # type: ignore
import watchfiles

from mewbot.api.v1 import IOConfig, Input, Output, InputEvent, OutputEvent


@dataclasses.dataclass
class FSInputEvent(InputEvent):
    """
    Base class for generic input events generated by the file system.
    """


@dataclasses.dataclass
class FileFSInputEvent(FSInputEvent):
    """
    Base class for file related input events generated by the file system.
    """

    file_path: str
    file_async_path: aiopath.AsyncPath


@dataclasses.dataclass
class CreatedFileFSInputEvent(FileFSInputEvent):
    """
    Called when a file is created - either at the location which is being monitored or inside a dir
    which is being monitored.
    """

    # file_size: str
    # entire_file: str
    # file_read_mode: str


@dataclasses.dataclass
class UpdatedFileFSInputEvent(FileFSInputEvent):
    """
    Called when a file is updated - either at the location which is being monitored or inside a dir
    which is being monitored.
    """

    # file_size: str
    # entire_file: str
    # file_read_mode: str


@dataclasses.dataclass
class DeletedFileFSInputEvent(FileFSInputEvent):
    """
    Called when a file is created - either at the location which is being monitored or inside a dir
    which is being monitored.
    Cannot provide any more information without caching a lot of details about the FS.
    """


@dataclasses.dataclass
class DirFSInputEvent(FSInputEvent):
    """
    Base class for file related input events generated by the file system.
    """

    dir_path: str
    dir_async_path: aiopath.AsyncPath


@dataclasses.dataclass
class CreatedDirFSInputEvent(DirFSInputEvent):
    """
    A dir has been created - either in the dir we're monitoring - if we're monitoring one.
    Or at the given monitor location.
    """


@dataclasses.dataclass
class UpdatedDirFSInputEvent(DirFSInputEvent):
    """
    A dir has been updated - either in the dir we're monitoring - if we're monitoring one.
    What this mostly means is the name of the dir has been updated.
    If the contents have been updated, it'll spew events of the appropriate type.
    """


@dataclasses.dataclass
class DeletedDirFSInputEvent(DirFSInputEvent):
    """
    A dir has been deleted - either in the dir we're monitoring - if we're monitoring one.
    """


@dataclasses.dataclass
class FSOutputEvent(OutputEvent):
    """
    Base class for generic input events generated by the file system.
    """


@dataclasses.dataclass
class FileFSOutputEvent(OutputEvent):
    """
    Base class for generic input events generated by the file system.
    """


@dataclasses.dataclass
class CreateFileFSOutputEvent(FileFSOutputEvent):
    """
    Creates a file with the given name.
    For security (and sanity) currently only created files in the designated output folder.
    """

    file_name: str
    file_contents: str


@dataclasses.dataclass
class AppendFileFSOutputEvent(FileFSOutputEvent):
    """
    Creates a file with the given name.
    For security (and sanity) currently only created files in the designated output folder.
    """

    file_name: str
    file_contents: str


@dataclasses.dataclass
class OverwriteFileFSOutputEvent(FileFSOutputEvent):
    """
    Creates a file with the given name.
    For security (and sanity) currently only created files in the designated output folder.
    """

    file_name: str
    file_contents: str


@dataclasses.dataclass
class DeleteFileFSOutputEvent(FileFSOutputEvent):
    """
    Creates a file with the given name.
    For security (and sanity) currently only created files in the designated output folder.
    """

    file_name: str


class FileSystemIO(IOConfig):

    _input: Optional[FileSystemInput] = None
    _output: Optional[FileSystemOutput] = None

    _input_path: Optional[str] = None
    _output_path: Optional[str] = None

    @property
    def input_path(self) -> Optional[str]:
        return self._input_path

    @input_path.setter
    def input_path(self, input_path: str) -> None:
        self._input_path = input_path

    @property
    def output_path(self) -> Optional[str]:
        return self._output_path

    @output_path.setter
    def output_path(self, output_path: str) -> None:
        self._output_path = output_path

    def get_inputs(self) -> Sequence[Input]:

        if not self._input:
            self._input = FileSystemInput(self._input_path)

        return [self._input]

    def get_outputs(self) -> Sequence[Output]:
        if not self._output:
            self._output = FileSystemOutput(self._output_path)

        return [self._output]


class FileSystemInput(Input):
    """
    Uses py-cord as a backend to connect, receive and send messages to discord.
    """

    _logger: logging.Logger
    _input_path: Optional[str] = None  # A location on the file system to monitor

    def __init__(self, input_path: Optional[str] = None) -> None:
        super(Input, self).__init__()  # pylint: disable=bad-super-call

        self._input_path = input_path
        self._logger = logging.getLogger(__name__ + "FileSystemInput")

        self.watcher = (
            watchfiles.awatch(self._input_path) if self._input_path is not None else None
        )

        # self._watch = asyncio.Lock()
        # # If _input_path is None, lock so that we won't run
        # # If not, leave the lock so it can be acquired
        # if self._input_path is None:
        #     self._watch.acquire()

    @staticmethod
    def produces_inputs() -> Set[Type[InputEvent]]:
        """Defines the set of input events this Input class can produce."""
        return {
            CreatedFileFSInputEvent,
            UpdatedFileFSInputEvent,
            DeletedFileFSInputEvent,
            CreatedDirFSInputEvent,
            UpdatedDirFSInputEvent,
            DeletedDirFSInputEvent,
        }

    @property
    def input_path(self) -> Optional[str]:
        return self._input_path

    @input_path.setter
    def input_path(self, new_input_path: Optional[str]) -> None:
        self._input_path = new_input_path

    async def run(self) -> None:
        """
        Fires up an aiohttp app to run the service.
        Token needs to be set by this point.
        """
        # Restart if the input path changes ... might be a good idea
        if self._input_path:
            self._logger.info('Starting FileSystemInput - monitoring "%s"', self._input_path)
        else:
            self._logger.info("Cannot start FileSystemInput - provided input path is None")
            return

        while True:

            await self._monitor_watcher()

    async def _monitor_watcher(self) -> None:
        """
        Actually do the job of monitoring and responding to the watcher.
        """
        if self.watcher is None:
            await asyncio.sleep(0.5)  # Give the rest of the loop a chance to act
            return

        async for changes in self.watcher:

            # Changes are sets of chance objects
            # tuples with the first entry being the type of change
            # the second element being the path to the changed item
            for change in changes:

                change_type, change_path = change

                if change_type == watchfiles.Change.added:
                    await self._do_add_event(change_path)

                elif change_type == watchfiles.Change.modified:
                    await self._do_update_event(change_path)

                elif change_type == watchfiles.Change.deleted:
                    await self._do_delete_event(change_path)

                else:
                    self._logger.warning(
                        "Unexpected case when trying to parse file change - %s", change_type
                    )

                print(change[0], type(change[0]), change[1], type(change[1]))

    async def send(self, event: FSInputEvent) -> None:

        if self.queue is None:
            return

        await self.queue.put(event)

    async def _do_add_event(self, change_path: str) -> None:
        """
        Called when a file or folder is added to the bit of the FS being monitored.
        """
        target_async_path = aiopath.AsyncPath(change_path)

        # Dealing with the dir case
        if await target_async_path.is_dir():
            await self.send(
                CreatedDirFSInputEvent(dir_path=change_path, dir_async_path=target_async_path)
            )

        # And now the file case
        else:
            await self.send(
                CreatedFileFSInputEvent(
                    file_path=change_path, file_async_path=target_async_path
                )
            )

    async def _do_update_event(self, change_path: str) -> None:
        """
        Called when there is an update detected in the bit of the FS being monitored.
        """
        target_async_path = aiopath.AsyncPath(change_path)

        # Dealing with the dir case
        if await target_async_path.is_dir():
            await self.send(
                UpdatedDirFSInputEvent(dir_path=change_path, dir_async_path=target_async_path)
            )

        # And now the file case
        else:
            await self.send(
                UpdatedFileFSInputEvent(
                    file_path=change_path, file_async_path=target_async_path
                )
            )

    async def _do_delete_event(self, change_path: str) -> None:
        """
        Called when there is an update detected in the bit of the FS being monitored.
        """
        target_async_path = aiopath.AsyncPath(change_path)

        # Dealing with the dir case
        if await target_async_path.is_dir():
            await self.send(
                DeletedDirFSInputEvent(dir_path=change_path, dir_async_path=target_async_path)
            )

        # And now the file case
        else:
            await self.send(
                DeletedFileFSInputEvent(
                    file_path=change_path, file_async_path=target_async_path
                )
            )


class FileSystemOutput(Output):

    _logger: logging.Logger
    _output_path: Optional[str]  # A location on the file system to monitor

    def __init__(self, output_path: Optional[str] = None) -> None:
        super(Output, self).__init__()  # pylint: disable=bad-super-call

        self._output_path = output_path
        self._logger = logging.getLogger(__name__ + "FileSystemOutput")

    @staticmethod
    def consumes_outputs() -> Set[Type[OutputEvent]]:
        """
        Defines the set of output events that this Output class can consume
        :return:
        """
        return {
            CreateFileFSOutputEvent,
            AppendFileFSOutputEvent,
            OverwriteFileFSOutputEvent,
            DeleteFileFSOutputEvent,
        }

    async def output(self, event: OutputEvent) -> bool:
        """
        Does the work of transmitting the event to the world.
        :param event:
        :return:
        """
        raise NotImplementedError("Not yet ready for prime time")
