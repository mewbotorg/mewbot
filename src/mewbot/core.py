#!/usr/bin/env python3

"""
Interfaces for Components and Events to pass between them.
These interfaces are the minimum guarantees for the implementations,
which will be consistent between API versions.

We can only define methods in these interfaces and not properties.
If a property-like behaviour becomes necessary, we can use an abstract @property.
"""

from __future__ import annotations

from typing import (
    Any,
    Dict,
    List,
    Protocol,
    Sequence,
    Set,
    Type,
    Union,
    runtime_checkable,
    Optional,
)

import asyncio
import enum
import dataclasses

from mewbot.data import DataSource


@dataclasses.dataclass
class InputEvent:
    """
    Base class for input events generated by the Inputs
    """


@dataclasses.dataclass
class OutputEvent:
    """
    Base class for output events generated by the Bot for transmission.
    """


InputQueue = asyncio.Queue[InputEvent]
OutputQueue = asyncio.Queue[OutputEvent]


@dataclasses.dataclass
class ManagerInputEvent:
    """
    Base class for input events flowing to the manager.
    Should (probably) not be used directly.
    """

    trigger_input_event: InputEvent

    # The io config containing the input which created this event
    io_config_src_uuid: str


@dataclasses.dataclass
class ManagerCommandInputEvent(ManagerInputEvent):
    """
    Base class for issuing commands to the manager.
    """


@dataclasses.dataclass
class ManagerInfoInputEvent(ManagerInputEvent):
    """
    Base class for passing information to the manager.
    May be information it has requested.
    """

    info_type: str = ""


@dataclasses.dataclass
class ManagerOutputEvent:
    """
    Base class for output events flowing out of the manager.
    Should (probably) not be used directly.
    """

    target_uuid: str  # The uuid of the component this message is for
    # Pass "all" to affect all components (usually a bad idea)

    # If this is a response by the manager to an input event, include it
    trigger_input_event: Optional[InputEvent]


@dataclasses.dataclass
class ManagerInfoOutputEvent(ManagerOutputEvent):
    """
    Info has been generated by the manager. It now needs to be disseminated.
    In some form.
    """

    send_type: str  # "multicast", "reply" e.t.c
    info_str: str  # info to send to the system


ManagerInputQueue = asyncio.Queue[ManagerInputEvent]
ManagerOutputQueue = asyncio.Queue[ManagerOutputEvent]


@runtime_checkable
class IOConfigInterface(Protocol):
    """
    Defines inputs and outputs to allow a bot to communicate with the outside world.
    """

    def get_inputs(self) -> Sequence[InputInterface]:
        """
        Type stub method.
        Returns the inputs defined in this IOConfig.
        """

    def get_outputs(self) -> Sequence[OutputInterface]:
        """
        Type stub method.
        Returns the outputs defined in this IOConfig
        """

    async def accept_manager_output(self, manager_output: ManagerOutputEvent) -> bool:
        """
        Can this IOConfig process a manager request?
        """

    async def status(self) -> Dict[str, List[str]]:
        """
        Generates a status object for this class.
        Prototype form - a dictionary keyed with "inputs" and "outputs" and valued with
        the results of calling status on each of those things.
        """

    def get_uuid(self) -> str:
        """
        Need to use this instead of a property to fool the type checking.
        """

    def set_io_config_uuids(self) -> None:
        """
        Iterates over the inputs and outputs, setting the io_config_uuid.
        """


@runtime_checkable
class InputInterface(Protocol):
    """
    Defines the interface for an input method - which produces InputEvent classes based
    on external events.
    These events are added to the InputQueue for the bot to process.
    """

    def get_uuid(self) -> str:
        """
        Returns the uuid of the Output.
        """

    def get_io_config_uuid(self) -> str:
        """
        Returns the uuid of the IOConfig this is part of
        """

    @staticmethod
    def produces_inputs() -> Set[Type[InputEvent]]:
        """
        Defines the set of input events this Input class can produce.
        """

    def bind(
        self,
        queue: InputQueue,
        manager_trigger_data: Optional[Dict[str, Set[str]]] = None,
        manager_input_queue: Optional[ManagerInputQueue] = None,
        manager_output_queue: Optional[ManagerOutputQueue] = None,
    ) -> None:
        """
        Add the queue(s) required for this interface to produce meaningful input.
        :param queue: Input queue to put input events on
        :param manager_trigger_data:
                Trigger data object required so this class knows if it is being issued
                a manager command or not
        :param manager_input_queue:
                Queue to put commands to the manager on.
        :param manager_output_queue:
                Queue to receive commands from the manager - if this class has a manager
                interface.
        :return:
        """

    async def run(self) -> None:
        """
        Commence processing events.
        :return:
        """

    async def status(self) -> str:
        """
        Simple string based status for this class.
        This component is intended to be part of an IOConfig class.
        As such it's the bottom of the component hierarchy - so the status string is simple.
        :return:
        """

    def set_io_config_uuid(self, new_uuid: str) -> None:
        """
        Set this class' instance of its parent IOConfig's class.
        :param new_uuid:
        :return:
        """


@runtime_checkable
class OutputInterface(Protocol):
    """
    Defines means for the bot to communicate back to the world.
    Is called directly by the bot rather than consuming from a queue.
    """

    @staticmethod
    def consumes_outputs() -> Set[Type[OutputEvent]]:
        """
        Defines the set of output events that this Output class can consume
        :return:
        """

    async def output(self, event: OutputEvent) -> bool:
        """
        Does the work of transmitting the event to the world.
        :param event:
        :return:
        """

    async def status(self) -> str:
        """
        Returns a status string representing the current state of the output method.
        :return:
        """

    def get_uuid(self) -> str:
        """
        Returns the uuid of the Output.
        """

    def get_io_config_uuid(self) -> str:
        """
        Returns the uuid of the IOConfig this is part of
        """

    def set_io_config_uuid(self, new_uuid: str) -> None:
        """
        Set the uuid of this output's parent IOConfig.
        :param new_uuid:
        :return:
        """


@runtime_checkable
class TriggerInterface(Protocol):
    """
    Triggers determine if behaviors should be run.
    """

    @staticmethod
    def consumes_inputs() -> Set[Type[InputEvent]]:
        """
        The set of InputEvent classes this trigger may consume.
        Used by the bot to determine if it should be called at all.
        :return:
        """

    def matches(self, event: InputEvent) -> bool:
        """
        Determines if an incoming event actually triggers this trigger
        :param event:
        :return: True - if the trigger is tripped
                 False - otherwise
        """


@runtime_checkable
class ConditionInterface(Protocol):
    """
    Effectively a second layer of trigger.
    After "is this event of interest" allows a second chance to reject the event.
    (e.g. the event might trip the trigger - but the condition is such that it cannot
    be responded to.
    It might be Tuesday - and the command is disabled on Tuesdays.
    Or the image cache may be full.
    E.t.c.
    """

    @staticmethod
    def consumes_inputs() -> Set[Type[InputEvent]]:
        """
        Classes this condition responds to.
        Note - if you have a trigger and a condition, the inputs of this should probably
        be a subset of those of the trigger.
        Note - this could be enforced with testing?
        Also - the union set of the consumes_inputs of all the Conditions should probably
        equal the union set of all the Triggers in a bot.
        :return:
        """

    def allows(self, event: InputEvent) -> bool:
        """
        Is the event allowed to proceed to triggering an Action?
        :param event:
        :return:
        """


@runtime_checkable
class ActionInterface(Protocol):
    """
    Class responsible for the transformation of Inputs into Outputs.
    Note - we consider that storing state in this class directly may be a mistake.
    It might be better to use a storage interface.
    """

    @staticmethod
    def consumes_inputs() -> Set[Type[InputEvent]]:
        """
        Input events this class can consume.
        :return:
        """

    @staticmethod
    def produces_outputs() -> Set[Type[OutputEvent]]:
        """
        Output events this class can produce for consumption by Outputs.
        :return:
        """

    def bind(self, queue: OutputQueue) -> None:
        """
        Add an OutputQueue for this class to communicate to the world.
        :param queue:
        :return:
        """

    async def act(self, event: InputEvent, state: Dict[str, Any]) -> None:
        """
        Transform an InputEvent to an OutputEvent and put it on the wire.
        :param event:
        :param state:
        :return:
        """


@runtime_checkable
class BehaviourInterface(Protocol):
    """
    Holder class for Trigger, Condition and Action.
    Together these classes form a behavior - a thing the bot does.
    """

    def add(
        self, component: Union[TriggerInterface, ConditionInterface, ActionInterface]
    ) -> None:
        """
        Register a component with this Behavior to form part of it.
        :param component:
        :return:
        """

    # Might want a produces_output class as well? For symmetry.
    def consumes_inputs(self) -> Set[Type[InputEvent]]:
        """
        What inputs does this behavior consume?
        Should be equivalent to a union of the inputs for all the triggers.
        :return:
        """

    def bind_output(self, output: OutputQueue) -> None:
        """
        Register the output queue used for outputting the results of this behvior.
        :param output:
        :return:
        """

    async def process(self, event: InputEvent) -> None:
        """
        Run the Trigger, Condition and Action process on an InputEvent to produce an Output.
        :param event:
        :return:
        """

    async def status(self) -> str:
        """
        Status for this behavior.
        :return:
        """
        return f"{self} doesn't have a status method"


@runtime_checkable
class ManagerInterface(Protocol):
    """
    Defines an interface that Manager objects have to adhere to.
    Managers (typically singletons) are responsible for providing control over a running
    bot and all the methods therein - allowing for interrogating components for status
    querying meta properties - such as lists of available commands and combined help strings
    Even disabling and re-enabling components.
    """

    def set_bot(self, new_bot: BotBase) -> None:
        """
        Set the bot the manager is managing.
        :param new_bot:
        :return:
        """

    def get_bot(self) -> BotBase:
        """
        Return the bot the manager is managing.
        :return:
        """

    def bind(self, in_queue: ManagerInputQueue, out_queue: ManagerOutputQueue) -> None:
        """
        Attach the manager to input and output queues for commands and commanding.
        :param in_queue:
        :param out_queue:
        :return:
        """

    def get_trigger_data(self) -> Dict[str, Set[str]]:
        """
        Return an object containing enough data for the inputs to tell if an event is
        intended as a command for the manager.
        :return:
        """

    def get_in_queue(self) -> Optional[ManagerInputQueue]:
        """
        Returns the ManagerInputQueue associated with this manager.
        This is how the manager receives input - both requests for data and commands.
        :return:
        """

    def get_out_queue(self) -> Optional[ManagerOutputQueue]:
        """
        Returns the ManagerOutputQueue associated with this manager.
        This is how the manager communicates back to the clients - either data requested
        or commands for them.
        :return:
        """

    def set_io_configs(self, io_configs: List[IOConfigInterface]) -> None:
        """
        The Manager needs to know the same IOConfigs as the Bot - allowing for direct control
        and communications.
        :param io_configs:
        :return:
        """

    async def process_manager_input_queue(self) -> None:
        """
        Take events off the manager input queue and respond to them.
        :return:
        """

    async def process_manager_output_queue(self) -> None:
        """
        Take events of the manager output queue and actually apply them to the specified objects.
        :return:
        """

    async def run(self) -> None:
        """
        Method which does the heavy lifting of getting the manager going.
        """

    async def status(self) -> Dict[str, Dict[str, Union[str, Dict[str, List[str]]]]]:
        """
        Status object representing all objects managed by the manager.
        :return:
        """

    async def help(self) -> Dict[str, Dict[str, str]]:
        """
        Generates a help object for the manager.
        :return:
        """


Component = Union[
    BehaviourInterface,
    IOConfigInterface,
    TriggerInterface,
    ConditionInterface,
    ActionInterface,
    ManagerInterface,
]


# pylint: disable=C0103
class ComponentKind(str, enum.Enum):
    Behaviour = "Behaviour"
    Trigger = "Trigger"
    Condition = "Condition"
    Action = "Action"
    IOConfig = "IOConfig"
    Template = "Template"
    DataSource = "DataSource"
    Manager = "Manager"

    @classmethod
    def values(cls) -> List[str]:
        return list(e for e in cls)

    @classmethod
    def interface(cls, value: ComponentKind) -> Type[Component]:
        _map: Dict[ComponentKind, Type[Component]] = {
            cls.Behaviour: BehaviourInterface,
            cls.Trigger: TriggerInterface,
            cls.Condition: ConditionInterface,
            cls.Action: ActionInterface,
            cls.IOConfig: IOConfigInterface,
            cls.Manager: ManagerInterface,
        }

        if value in _map:
            return _map[value]

        raise ValueError(f"Invalid value {value}")


class BotBase:
    """
    Base class for all bots.
    Mostly an ancestor class stub needed for type checking in the manager class.
    """

    name: str  # The bot's name

    _io_configs: List[IOConfigInterface]  # Connections to bot makes to other services
    _behaviours: List[BehaviourInterface]  # All the things the bot does
    _datastores: Dict[str, DataSource[Any]]  # Data sources and stores for this bot

    _manager: Optional[ManagerInterface]

    def add_io_config(self, ioc: IOConfigInterface) -> None:
        """
        Add an IOConfig to the manager.
        :param ioc:
        :return:
        """
        self._io_configs.append(ioc)

    def add_behaviour(self, behaviour: BehaviourInterface) -> None:
        """
        Add a ready-to-run Behavior to the manager.
        :param behaviour:
        :return:
        """
        self._behaviours.append(behaviour)

    def set_manager(self, manager: ManagerInterface) -> None:
        """
        Assign a Manager (possibly the only one in the program) to this bot.
        :param manager:
        :return:
        """
        self._manager = manager
        self._manager.set_bot(self)

    def get_manager(self) -> Optional[ManagerInterface]:
        """
        Return the Manager object - if the Bot has been assigned one.
        :return:
        """
        if hasattr(self, "_manager"):
            return self._manager
        return None

    def get_data_source(self, name: str) -> Optional[DataSource[Any]]:
        """
        Return a Datasource known to the Bot.
        :param name:
        :return:
        """
        return self._datastores.get(name)

    def get_io_configs(self) -> List[IOConfigInterface]:
        """
        A list of all the IOConfigs know to the bot.
        Note - updating the return object wil NOT update the bot's IOConfigs once run has been
        called.
        """
        return self._io_configs

    # def get_datastores(self) -> List[DatastoreInterface]:

    def get_behaviours(self) -> List[BehaviourInterface]:
        """
        A list of all the behaviors known to the bot.
        Note - updating the return object wil NOT update the bot's Behaviors once run has been
        called.
        """
        return self._behaviours


__all__ = [
    "ComponentKind",
    "Component",
    "IOConfigInterface",
    "InputInterface",
    "OutputInterface",
    "BehaviourInterface",
    "TriggerInterface",
    "ConditionInterface",
    "ActionInterface",
    "ManagerInterface",
    "InputEvent",
    "OutputEvent",
    "ManagerInputEvent",
    "ManagerInfoInputEvent",
    "ManagerOutputEvent",
    "ManagerInfoOutputEvent",
    "ManagerCommandInputEvent",
    "ManagerInputQueue",
    "ManagerOutputQueue",
    "InputQueue",
    "OutputQueue",
    "BotBase",
]
