#!/usr/bin/env python3

"""
Interfaces for Components and Events to pass between them.
These interfaces are the minimum guarantees for the implementations,
which will be consistent between API versions.

We can only define methods in these interfaces and not properties.
If a property-like behaviour becomes necessary, we can use an abstract @property.
"""

from __future__ import annotations

from typing import (
    Any,
    Dict,
    List,
    Protocol,
    Sequence,
    Set,
    Type,
    Union,
    runtime_checkable,
    Optional,
)

import asyncio
import enum
import dataclasses

from mewbot.data import DataSource


@dataclasses.dataclass
class InputEvent:
    pass


@dataclasses.dataclass
class OutputEvent:
    pass


InputQueue = asyncio.Queue[InputEvent]
OutputQueue = asyncio.Queue[OutputEvent]


@dataclasses.dataclass
class ManagerInputEvent:
    """
    Base class for input events flowing to the manager.
    Should (probably) not be used directly.
    """

    trigger_input_event: InputEvent


@dataclasses.dataclass
class ManagerCommandInputEvent(ManagerInputEvent):
    """
    Base class for issuing commands to the manager.
    """


@dataclasses.dataclass
class ManagerInfoInputEvent(ManagerInputEvent):
    """
    Base class for passing information to the manager.
    May be information it has requested.
    """

    info_type: str = ""


@dataclasses.dataclass
class ManagerOutputEvent:
    """
    Base class for output events flowing out of the manager.
    Should (probably) not be used directly.
    """

    # If this is a response by the manager to an input event, include it
    trigger_input_event: Optional[InputEvent]


@dataclasses.dataclass
class ManagerInfoOutputEvent(ManagerOutputEvent):
    """
    Info has been generated by the manager. It now needs to be disseminated.
    In some form.
    """

    send_type: str  # "multicast", "reply" e.t.c
    info_str: str  # info to send to the system


ManagerInputQueue = asyncio.Queue[ManagerInputEvent]
ManagerOutputQueue = asyncio.Queue[ManagerOutputEvent]


@runtime_checkable
class IOConfigInterface(Protocol):
    def get_inputs(self) -> Sequence[InputInterface]:
        pass

    def get_outputs(self) -> Sequence[OutputInterface]:
        pass

    async def status(self) -> Dict[str, List[str]]:
        pass


@runtime_checkable
class InputInterface(Protocol):
    @staticmethod
    def produces_inputs() -> Set[Type[InputEvent]]:
        """
        Defines the set of input events this Input class can produce.
        """

    def bind(
        self,
        queue: InputQueue,
        manager_trigger_data: Optional[Dict[str, Set[str]]] = None,
        manager_input_queue: Optional[ManagerInputQueue] = None,
        manager_output_queue: Optional[ManagerOutputQueue] = None,
    ) -> None:
        pass

    async def run(self) -> None:
        pass

    async def status(self) -> str:
        pass


@runtime_checkable
class OutputInterface(Protocol):
    @staticmethod
    def consumes_outputs() -> Set[Type[OutputEvent]]:
        """
        Defines the set of output events that this Output class can consume
        :return:
        """

    async def output(self, event: OutputEvent) -> bool:
        """
        Does the work of transmitting the event to the world.
        :param event:
        :return:
        """

    async def status(self) -> str:
        pass


@runtime_checkable
class TriggerInterface(Protocol):
    @staticmethod
    def consumes_inputs() -> Set[Type[InputEvent]]:
        pass

    def matches(self, event: InputEvent) -> bool:
        pass


@runtime_checkable
class ConditionInterface(Protocol):
    @staticmethod
    def consumes_inputs() -> Set[Type[InputEvent]]:
        pass

    def allows(self, event: InputEvent) -> bool:
        pass


@runtime_checkable
class ActionInterface(Protocol):
    @staticmethod
    def consumes_inputs() -> Set[Type[InputEvent]]:
        pass

    @staticmethod
    def produces_outputs() -> Set[Type[OutputEvent]]:
        pass

    def bind(self, queue: OutputQueue) -> None:
        pass

    async def act(self, event: InputEvent, state: Dict[str, Any]) -> None:
        pass


@runtime_checkable
class BehaviourInterface(Protocol):
    def add(
        self, component: Union[TriggerInterface, ConditionInterface, ActionInterface]
    ) -> None:
        pass

    def consumes_inputs(self) -> Set[Type[InputEvent]]:
        pass

    def bind_output(self, output: OutputQueue) -> None:
        pass

    async def process(self, event: InputEvent) -> None:
        pass

    async def status(self) -> str:
        return f"{self} doesn't have a status method"


@runtime_checkable
class ManagerInterface(Protocol):
    def set_bot(self, new_bot: BotBase) -> None:
        pass

    def get_bot(self) -> BotBase:
        pass

    def bind(self, in_queue: ManagerInputQueue, out_queue: ManagerOutputQueue) -> None:
        pass

    def get_trigger_data(self) -> Dict[str, Set[str]]:
        pass

    def get_in_queue(self) -> Optional[ManagerInputQueue]:
        pass

    def get_out_queue(self) -> Optional[ManagerOutputQueue]:
        pass

    async def run(self) -> None:
        pass

    async def status(self) -> Dict[str, Dict[str, Union[str, Dict[str, List[str]]]]]:
        pass

    async def help(self) -> Dict[str, Dict[str, str]]:
        pass


Component = Union[
    BehaviourInterface,
    IOConfigInterface,
    TriggerInterface,
    ConditionInterface,
    ActionInterface,
    ManagerInterface,
]


# pylint: disable=C0103
class ComponentKind(str, enum.Enum):
    Behaviour = "Behaviour"
    Trigger = "Trigger"
    Condition = "Condition"
    Action = "Action"
    IOConfig = "IOConfig"
    Template = "Template"
    DataSource = "DataSource"
    Manager = "Manager"

    @classmethod
    def values(cls) -> List[str]:
        return list(e for e in cls)

    @classmethod
    def interface(cls, value: ComponentKind) -> Type[Component]:
        _map: Dict[ComponentKind, Type[Component]] = {
            cls.Behaviour: BehaviourInterface,
            cls.Trigger: TriggerInterface,
            cls.Condition: ConditionInterface,
            cls.Action: ActionInterface,
            cls.IOConfig: IOConfigInterface,
            cls.Manager: ManagerInterface,
        }

        if value in _map:
            return _map[value]

        raise ValueError(f"Invalid value {value}")


class BotBase:
    """
    Base class for all bots.
    Mostly an ancestor class stub needed for type checking in the manager class.
    """

    name: str  # The bot's name

    _io_configs: List[IOConfigInterface]  # Connections to bot makes to other services
    _behaviours: List[BehaviourInterface]  # All the things the bot does
    _datastores: Dict[str, DataSource[Any]]  # Data sources and stores for this bot

    _manager: Optional[ManagerInterface]

    def add_io_config(self, ioc: IOConfigInterface) -> None:
        self._io_configs.append(ioc)

    def add_behaviour(self, behaviour: BehaviourInterface) -> None:
        self._behaviours.append(behaviour)

    def set_manager(self, manager: ManagerInterface) -> None:
        self._manager = manager
        self._manager.set_bot(self)

    def get_manager(self) -> Optional[ManagerInterface]:
        if hasattr(self, "_manager"):
            return self._manager
        return None

    def get_data_source(self, name: str) -> Optional[DataSource[Any]]:
        return self._datastores.get(name)

    def get_io_configs(self) -> List[IOConfigInterface]:
        """
        A list of all the IOConfigs know to the bot.
        Note - updating the return object wil NOT update the bot's IOConfigs once run has been
        called.
        """
        return self._io_configs

    # def get_datastores(self) -> List[DatastoreInterface]:

    def get_behaviours(self) -> List[BehaviourInterface]:
        """
        A list of all the behaviors known to the bot.
        Note - updating the return object wil NOT update the bot's Behaviors once run has been
        called.
        """
        return self._behaviours


__all__ = [
    "ComponentKind",
    "Component",
    "IOConfigInterface",
    "InputInterface",
    "OutputInterface",
    "BehaviourInterface",
    "TriggerInterface",
    "ConditionInterface",
    "ActionInterface",
    "ManagerInterface",
    "InputEvent",
    "OutputEvent",
    "ManagerInputEvent",
    "ManagerInfoInputEvent",
    "ManagerOutputEvent",
    "ManagerInfoOutputEvent",
    "ManagerCommandInputEvent",
    "ManagerInputQueue",
    "ManagerOutputQueue",
    "InputQueue",
    "OutputQueue",
]
