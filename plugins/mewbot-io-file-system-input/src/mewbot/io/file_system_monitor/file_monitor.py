# !/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 Mewbot Developers <mewbot@quicksilver.london>
#
# SPDX-License-Identifier: BSD-2-Clause

"""
Stores the file monitor components for the file system monitor.
"""

from __future__ import annotations

from typing import AsyncGenerator, Optional, Set, Tuple

import asyncio
import logging

import aiopath  # type: ignore
import watchfiles

from mewbot.api.v1 import InputEvent
from mewbot.io.file_system_monitor.fs_events import (
    FileCreatedAtWatchLocationFSInputEvent,
    FileDeletedFromWatchLocationFSInputEvent,
    FileUpdatedAtWatchLocationFSInputEvent,
    FSInputEvent,
)


class BaseFileMonitorMixin:
    """
    Provides tools to watch a file for changes to it.
    """

    _logger: logging.Logger

    _input_path: Optional[str] = None  # A location on the file system to monitor
    _input_path_exists: bool = False
    _input_path_type: Optional[str] = None

    _polling_interval: float = 0.5

    watcher: Optional[AsyncGenerator[Set[Tuple[watchfiles.Change, str]], None]]

    queue: asyncio.Queue[FSInputEvent]

    async def send(self, event: FSInputEvent) -> None:
        """
        Put an event generated by one of the monitors on the file.

        :param event:
        :return:
        """
        if self.queue is None:
            return

        await self.queue.put(event)

    async def _input_path_file_created_task(
        self, target_async_path: aiopath.AsyncPath
    ) -> None:
        """
        Called when _monitor_file detects that there's now something at the input_path location.

        Spun off into a separate method because want to get into starting the watch as fast as
        possible.
        """
        if self._input_path is None:
            self._logger.warning(
                "Unexpected call to _input_path_file_created_task - _input_path is None!"
            )
            return

        if self._input_path is not None and self._input_path_type == "dir":
            self._logger.warning(
                "Unexpected call to _input_path_file_created_task - "
                "_input_path is not None but _input_path_type is dir"
            )

        str_path: str = self._input_path

        if await target_async_path.is_dir():
            self._logger.info('New asset at "%s" detected as dir', self._input_path)

        elif await target_async_path.is_file():
            self._logger.info('New asset at "%s" detected as file', self._input_path)

            await self.send(
                FileCreatedAtWatchLocationFSInputEvent(path=str_path, base_event=None)
            )

        else:
            self._logger.warning(
                "Unexpected case in _input_path_created_task - %s", target_async_path
            )

    async def _monitor_file_watcher(self) -> None:
        """
        Actually do the job of monitoring and responding to the watcher.

        If the file is detected as deleted, then the
        """
        # Ideally this would be done with some kind of run-don't run lock
        # Waiting on better testing before attempting that.
        if self.watcher is None:
            self._logger.info("Unexpected case - self.watcher is None in _monitor_watcher")
            await asyncio.sleep(
                self._polling_interval
            )  # Give the rest of the loop a chance to act
            return

        async for changes in self.watcher:
            file_deleted = await self._process_changes(changes)

            if file_deleted:
                # File is detected as deleted
                # - shutdown the watcher
                # - indicate we need to start monitoring for a new file
                # (or folder - in which case this will do nothing more)
                # - (Putting an event to indicate this on the wire should have happened elsewhere)
                self.watcher = None
                self._input_path_exists = False

                return

    async def _process_changes(self, changes: Set[tuple[watchfiles.Change, str]]) -> bool:
        """
        Turn the product of a watchfile watcher into events to put on the wire.

        :param changes:
        :return:
        """
        # Changes are sets of chance objects
        # tuples with
        #  - the first entry being a watchfiles.Change object
        #  - the second element being a str path to the changed item

        for change in changes:
            change_type, change_path = change

            if change_type == watchfiles.Change.added:
                self._logger.warning(
                    "With how we are using watchfiles this point should never be reached "
                    "- %s - '%s'",
                    change_type,
                    change_path,
                )

            elif change_type == watchfiles.Change.modified:
                await self._do_update_event(change_path, change)

            elif change_type == watchfiles.Change.deleted:
                await self._do_delete_event(change_path, change)
                return True

            else:
                self._logger.warning(
                    "Unexpected case when trying to parse file change - %s", change_type
                )

        return False

    async def _do_update_event(
        self, change_path: str, raw_change: tuple[watchfiles.Change, str]
    ) -> None:
        """
        Called when the monitored file is updated.
        """
        await self.send(
            FileUpdatedAtWatchLocationFSInputEvent(
                path=change_path,
                base_event=raw_change,
            )
        )

    async def _do_delete_event(
        self, change_path: str, raw_change: tuple[watchfiles.Change, str]
    ) -> None:
        """
        Called when the monitored file is deleted.
        """
        await self.send(
            FileDeletedFromWatchLocationFSInputEvent(
                path=change_path,
                base_event=raw_change,
            )
        )

    async def _monitor_input_path(self) -> None:
        """
        Preforms a check on the monitored location - updating the properties of the class.

        Several properties are cached.
        """
        if self._input_path_exists and self._input_path_type == "file":
            return

        self._logger.info(
            "The provided input path will be monitored until a file appears - %s - %s",
            self._input_path,
            self._input_path_type,
        )

        while True:
            if self._input_path is None:
                await asyncio.sleep(
                    self._polling_interval
                )  # Give the rest of the loop a chance to do something
                continue

            target_async_path: aiopath.AsyncPath = aiopath.AsyncPath(self._input_path)
            target_exists: bool = await target_async_path.exists()
            is_target_dir: bool = await target_async_path.is_dir()
            if not target_exists:
                await asyncio.sleep(
                    self._polling_interval
                )  # Give the rest of the loop a chance to do something
                continue

            if target_exists and is_target_dir:
                await asyncio.sleep(
                    self._polling_interval
                )  # Give the rest of the loop a chance to do something
                continue

            # Something has come into existence since the last loop
            self._logger.info(
                "Something has appeared at the input_path - %s", self._input_path
            )

            # All the logic which needs to be run when a file is created at the target location
            # Aim is to get the event on the wire as fast as possible, so as to start the watcher
            # To minimize the chance of missing events
            asyncio.get_running_loop().create_task(
                self._input_path_file_created_task(target_async_path)
            )

            self.watcher = watchfiles.awatch(self._input_path)
            self._input_path_exists = True
            return
